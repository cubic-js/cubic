{"version":3,"file":"browser.js","sources":["node_modules/ws/index.js","node_modules/async-mutex/lib/Mutex.js","node_modules/async-mutex/lib/index.js","src/node/connection.js","src/node/serverError.js","src/node/api.js","src/node/auth.js","src/node/client.js","src/node/index.js","src/browser/connection.js","src/browser/auth.js","src/browser/api.js","src/browser/client.js","src/browser/index.js"],"sourcesContent":["export default {}","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Mutex = /** @class */ (function () {\n    function Mutex() {\n        this._queue = [];\n        this._pending = false;\n    }\n    Mutex.prototype.isLocked = function () {\n        return this._pending;\n    };\n    Mutex.prototype.acquire = function () {\n        var _this = this;\n        var ticket = new Promise(function (resolve) { return _this._queue.push(resolve); });\n        if (!this._pending) {\n            this._dispatchNext();\n        }\n        return ticket;\n    };\n    Mutex.prototype.runExclusive = function (callback) {\n        return this\n            .acquire()\n            .then(function (release) {\n            var result;\n            try {\n                result = callback();\n            }\n            catch (e) {\n                release();\n                throw (e);\n            }\n            return Promise\n                .resolve(result)\n                .then(function (x) { return (release(), x); }, function (e) {\n                release();\n                throw e;\n            });\n        });\n    };\n    Mutex.prototype._dispatchNext = function () {\n        if (this._queue.length > 0) {\n            this._pending = true;\n            this._queue.shift()(this._dispatchNext.bind(this));\n        }\n        else {\n            this._pending = false;\n        }\n    };\n    return Mutex;\n}());\nexports.default = Mutex;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Mutex_1 = require(\"./Mutex\");\nexports.Mutex = Mutex_1.default;\n","const WebSocket = require('ws')\r\nconst Mutex = require('async-mutex').Mutex\r\n\r\n// Pseudo helper enum for Websocket states\r\nconst state = {\r\n  CONNECTING: 0,\r\n  OPEN: 1,\r\n  CLOSING: 2,\r\n  CLOSED: 3\r\n}\r\n\r\n/**\r\n * Connection class.\r\n * Here is where the actual WebSocket connection and logic gets handled.\r\n */\r\nclass Connection {\r\n  constructor (url, options) {\r\n    this.url = url\r\n    this.options = options\r\n    this.timeout = 1000 * 30 || options.timeout\r\n    this.req = { delay: this.options.requestDelay || 500, counter: 0 }\r\n    this.reconnect = { delay: this.options.reconnectDelay || 500, counter: 0 }\r\n\r\n    this.lastHeartbeat = new Date()\r\n    this.subscriptions = []\r\n    this.requests = []\r\n    this.retryQueue = []\r\n    this.requestIds = 1\r\n    this.mutex = new Mutex()\r\n\r\n    // Heartbeat check. If the heartbeat takes too long we can assume the connection died.\r\n    setInterval(async () => {\r\n      if (new Date() - this.lastHeartbeat > this.timeout && this.isConnected()) this.connection.close(1001, 'Heartbeat took too long.')\r\n    }, this.timeout)\r\n\r\n    // Call once to start processing retry queue\r\n    this._processRetryQueue()\r\n  }\r\n\r\n  async connect () {\r\n    const release = await this.mutex.acquire()\r\n    await this._createConnection()\r\n    release()\r\n  }\r\n\r\n  /**\r\n   * Helper function to wait for connection to go up\r\n   */\r\n  awaitConnection () {\r\n    return new Promise((resolve) => {\r\n      if (this.isConnected()) resolve()\r\n      const poll = setInterval(() => {\r\n        if (this.isConnected()) {\r\n          clearInterval(poll)\r\n          resolve()\r\n        }\r\n      }, 100)\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Helper function to see if connection is open\r\n   */\r\n  isConnected () {\r\n    return this.connection && this.connection.readyState === state.OPEN\r\n  }\r\n\r\n  /**\r\n   * Make a request\r\n   */\r\n  async request (verb, query, retry = false) {\r\n    await this.awaitConnection()\r\n    return new Promise((resolve) => {\r\n      const id = this.requestIds++\r\n      const payload = { action: verb, id }\r\n      if (typeof query === 'string') payload.url = query\r\n      else {\r\n        payload.url = query.url\r\n        payload.body = query.body\r\n      }\r\n\r\n      this.requests.push({ id, resolve, verb, query, retry })\r\n      try {\r\n        this.connection.send(JSON.stringify(payload))\r\n      } catch (err) {\r\n        this.requests.pop()\r\n        this.connection.emit('error', err)\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Reload the websocket connection\r\n   */\r\n  async reloadConnection () {\r\n    await this.awaitConnection()\r\n    await this.connection.close(1001, 'Reloading connection.')\r\n  }\r\n\r\n  /**\r\n   * Push a retry into the retry queue\r\n   */\r\n  async retry (req) {\r\n    this.retryQueue.push({\r\n      verb: req.verb,\r\n      query: req.query,\r\n      id: req.retry || req.id, // Use retry id if retrying a retry, otherwise the original id,\r\n      customDelay: req.customDelay || null\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Processes the retry queue with the correct delay.\r\n   * Needs to be called once on startup.\r\n   */\r\n  async _processRetryQueue () {\r\n    const currentReqCount = this.req.counter\r\n\r\n    const retry = this.retryQueue.shift()\r\n    let customDelay = false\r\n    if (retry) {\r\n      // If theres a custom delay, put back into queue and wait the custom delay\r\n      if (retry.customDelay) {\r\n        customDelay = retry.customDelay\r\n        delete retry.customDelay\r\n        this.retryQueue.unshift(retry)\r\n\r\n        // Otherwise make a request\r\n      } else {\r\n        this.request(retry.verb, retry.query, retry.id)\r\n        this.req.counter++\r\n      }\r\n    }\r\n\r\n    setTimeout(() => this._processRetryQueue(), customDelay || this.req.delay * Math.pow(2, currentReqCount))\r\n  }\r\n\r\n  /**\r\n   * Reconnection logic\r\n   */\r\n  async _reconnect () {\r\n    const release = await this.mutex.acquire()\r\n\r\n    // Return if connection is connecting or already open\r\n    if (this.connection && this.connection.readyState <= state.OPEN) {\r\n      release()\r\n      return\r\n    }\r\n\r\n    // Wait reconnection delay\r\n    await new Promise((resolve) => setTimeout(() => resolve(), this.reconnect.delay * Math.pow(2, this.reconnect.counter)))\r\n    this.reconnect.counter++\r\n    await this._createConnection()\r\n\r\n    release()\r\n  }\r\n\r\n  /**\r\n   * Resume requests and rebuild subscriptions\r\n   */\r\n  async _resumeConnection () {\r\n    // Resume requests that were not completed before disconnect\r\n    for (const req of this.requests) this.retry(req)\r\n\r\n    // Re-subscribe\r\n    for (const sub of this.subscriptions) {\r\n      this.connection.send(JSON.stringify({\r\n        action: 'SUBSCRIBE',\r\n        room: sub.room\r\n      }))\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create WebSocket connection\r\n   */\r\n  async _createConnection () {\r\n    const options = this.apiAccessToken ? {\r\n      headers: {\r\n        authorization: `bearer ${this.apiAccessToken}`\r\n      }\r\n    } : {}\r\n\r\n    const wss = new WebSocket(this.url, options)\r\n    wss.onopen = () => this._resumeConnection()\r\n    wss.onerror = (error) => console.log(`WebSocket Error: ${error.message}`)\r\n    wss.onclose = (close) => { if (close.code !== 1000) this._reconnect() } // Not closed deliberately\r\n    wss.onmessage = (message) => this._onMessage(message.data)\r\n    this.connection = wss\r\n  }\r\n\r\n  /**\r\n   * WebSocket message handling\r\n   */\r\n  async _onMessage (data) {\r\n    data = JSON.parse(data)\r\n\r\n    // Heartbeat\r\n    if (typeof data === 'string' && data.startsWith('primus::ping::')) {\r\n      this.lastHeartbeat = new Date()\r\n      this.connection.send(JSON.stringify(data.replace('ping', 'pong')))\r\n      this.reconnect.counter = 0 // Assume stable connection if heartbeat is received\r\n    }\r\n\r\n    // Request\r\n    else if (data.action === 'RES' && data.id) {\r\n      this._processResponse(data)\r\n    }\r\n\r\n    // Publish to subscriptions\r\n    else if (data.action === 'PUBLISH') {\r\n      for (const sub of this.subscriptions) {\r\n        if (sub.room === data.room) sub.fn(data.data)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Processes incoming request response\r\n   */\r\n  async _processResponse (data) {\r\n    const request = this.requests.find(r => r.id === data.id)\r\n    if (!request) return\r\n\r\n    // Retry if error occurred\r\n    const response = await this._errCheck(data, request.verb, request.query)\r\n    if (!response) {\r\n      // Append custom wait delay\r\n      let customDelay = data.body && data.body.reason ? parseInt(data.body.reason.replace(/[^0-9]+/g, '')) : undefined\r\n      request.customDelay = isNaN(customDelay) ? undefined : customDelay\r\n\r\n      this.retry(request)\r\n      return\r\n    }\r\n\r\n    // Reset req counter and resolve\r\n    this.req.counter = 0\r\n    request.resolve(response)\r\n    const originalRequest = request.retry ? this.requests.find(r => r.id === request.retry) : null\r\n    if (originalRequest) originalRequest.resolve(response)\r\n\r\n    // If original request: Filter original request and all that have the original req as retry target\r\n    // If retry request: Filter retried request and all that have the retried req as retry target\r\n    const originalFilter = (r) => r.id !== request.id && r.retry !== request.id\r\n    const retryFilter = (r) => r.id !== request.retry && r.retry !== request.retry\r\n    this.requests = this.requests.filter(!request.retry ? originalFilter : retryFilter)\r\n  }\r\n\r\n  /**\r\n   * Handle error responses. Return false on error, otherwise some truthy value.\r\n   * It's expected that you override this in a child class for more fine-grained error control.\r\n   */\r\n  async _errCheck (res, verb, query) {\r\n    if (res.body.error) throw res\r\n    else return res.body\r\n  }\r\n}\r\n\r\nmodule.exports = Connection\r\n","class ServerError extends Error {\r\n  constructor ({ statusCode, body }, query) {\r\n    const error = body.error ? body.error + `(${body.reason})` : body\r\n    super(`Cubic-client encountered an error while requesting ${query.url || query}: ${statusCode} - ${error}`)\r\n    this.statusCode = statusCode\r\n    this.reason = body.reason\r\n    this.error = body.error\r\n  }\r\n}\r\n\r\nmodule.exports = ServerError\r\n","const Connection = require('./connection.js')\r\nconst ServerError = require('./serverError.js')\r\n\r\n/**\r\n * API class.\r\n * Handles the connection to the API server.\r\n */\r\nclass API extends Connection {\r\n  /**\r\n   * Sets access token for API\r\n   */\r\n  async setAccessToken (token) {\r\n    this.apiAccessToken = token\r\n  }\r\n\r\n  async _errCheck (res, verb, query) {\r\n    // If expired: return custom object to so parent client can refresh token\r\n    if (res.body && res.body.reason && res.body.reason.includes('jwt expired')) {\r\n      return { EXPIRED: true, verb, query }\r\n    }\r\n\r\n    // Request timed out in queue stack -> push it back to the end\r\n    else if (!res.statusCode && res.includes('timed out')) return false\r\n\r\n    // Rate Limited\r\n    else if (res.statusCode === 429) return false\r\n\r\n    // Nodes are busy -> retry\r\n    else if (res.statusCode === 503) return false\r\n\r\n    // Unhandled error\r\n    else if (parseInt(res.statusCode.toString().charAt(0)) > 3) throw new ServerError(res, query)\r\n\r\n    // No error\r\n    return res.body\r\n  }\r\n}\r\n\r\nmodule.exports = API\r\n","const Connection = require('./connection.js')\r\nconst Mutex = require('async-mutex').Mutex\r\n\r\n/**\r\n * Authentication class.\r\n * Handles the connection to the auth server.\r\n */\r\nclass Auth extends Connection {\r\n  constructor (url, options) {\r\n    super(url, options)\r\n\r\n    this.authMutex = new Mutex()\r\n  }\r\n\r\n  /**\r\n   * Get tokens for API authentication if credentials are provided\r\n   */\r\n  authorize (refresh = this.refresh_token) {\r\n    if (refresh || (this.options.user_key && this.options.user_secret)) {\r\n      return refresh ? this._refreshToken() : this._getTokens()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Runtime login\r\n   */\r\n  login (user, secret) {\r\n    this.options.user_key = user\r\n    this.options.user_secret = secret\r\n    return this._getTokens()\r\n  }\r\n\r\n  /**\r\n   * Get tokens via /authenticate request\r\n   */\r\n  async _getTokens () {\r\n    const body = {\r\n      user_key: this.options.user_key,\r\n      user_secret: this.options.user_secret\r\n    }\r\n\r\n    const res = await this.request('POST', { url: '/authenticate', body })\r\n    this.access_token = res.access_token\r\n    this.refresh_token = res.refresh_token\r\n  }\r\n\r\n  /**\r\n   * Generate new access token\r\n   */\r\n  async _refreshToken () {\r\n    const release = await this.authMutex.acquire()\r\n\r\n    const body = { refresh_token: this.refresh_token }\r\n    const res = await this.request('POST', { url: '/refresh', body })\r\n    this.access_token = res.access_token\r\n\r\n    release()\r\n  }\r\n\r\n  async _errCheck (res, verb, query) {\r\n    // Auth error\r\n    if (res.statusCode >= 400) {\r\n      if (res.statusCode !== 503 && res.statusCode !== 404 && res.statusCode !== 429) {\r\n        console.error('Cubic-client encountered an error while authenticating:')\r\n        console.error(res.body)\r\n        console.error(`retrying... \\n`)\r\n      }\r\n      return false\r\n    }\r\n\r\n    // No error\r\n    return res.body\r\n  }\r\n}\r\n\r\nmodule.exports = Auth\r\n","const API = require('./api.js')\r\nconst Auth = require('./auth.js')\r\n\r\n/**\r\n * Client class.\r\n * This is the actual client that handles auth and api logic.\r\n */\r\nclass Client {\r\n  constructor (options) {\r\n    this.options = options\r\n\r\n    if (!this.options.isBrowser) {\r\n      this.api = new API(this.options.api_url, this.options)\r\n      this.auth = new Auth(this.options.auth_url, {\r\n        user_key: this.options.user_key,\r\n        user_secret: this.options.user_secret\r\n      })\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Helper functions to wait for connection to go up\r\n   */\r\n  awaitConnection () {\r\n    return Promise.all([this.api.awaitConnection(), this.auth.awaitConnection()])\r\n  }\r\n\r\n  async connect () {\r\n    await this.auth.connect()\r\n    await this.auth.authorize()\r\n    await this.api.setAccessToken(this.auth.access_token)\r\n    await this.api.connect()\r\n  }\r\n\r\n  async query (verb, query) {\r\n    const res = await this.api.request(verb, query)\r\n\r\n    // Refresh token if expired\r\n    if (res.EXPIRED) {\r\n      await this.auth.authorize()\r\n      await this.api.setAccessToken(this.auth.access_token)\r\n      await this.api.reloadConnection()\r\n      return this.query(res.verb, res.query)\r\n    }\r\n\r\n    return res\r\n  }\r\n\r\n  /**\r\n   * Subscribe to certain endpoints\r\n   */\r\n  async subscribe (room, fn) {\r\n    await this.api.awaitConnection()\r\n    this.api.connection.send(JSON.stringify({\r\n      action: 'SUBSCRIBE',\r\n      room\r\n    }))\r\n    this.api.subscriptions.push({ room, fn })\r\n  }\r\n\r\n  /**\r\n   * Unsubscribe from endpoints again\r\n   */\r\n  async unsubscribe (room) {\r\n    await this.api.awaitConnection()\r\n    this.api.connection.send(JSON.stringify({\r\n      action: 'UNSUBSCRIBE',\r\n      room\r\n    }))\r\n    this.api.subscriptions = this.api.subscriptions.filter(s => s.room !== room)\r\n  }\r\n\r\n  /**\r\n   * Change auth user and reload api\r\n   */\r\n  async login (user, secret) {\r\n    await this.awaitConnection()\r\n    await this.auth.login(user, secret)\r\n    await this.api.setAccessToken(this.auth.access_token)\r\n    await this.api.reloadConnection()\r\n  }\r\n\r\n  /**\r\n   * Set access token and reload api\r\n   */\r\n  async setAccessToken (token) {\r\n    this.auth.access_token = token\r\n    await this.api.setAccessToken(this.auth.access_token)\r\n    await this.api.reloadConnection()\r\n  }\r\n}\r\n\r\nmodule.exports = Client\r\n","const Client = require('./client.js')\r\n\r\n/**\r\n * Client API. Provides a public interface for the actual client.\r\n */\r\nclass Interface {\r\n  constructor (options) {\r\n    this.options = {\r\n      ...{\r\n        api_url: 'ws://localhost:3003/ws',\r\n        auth_url: 'ws://localhost:3030/ws',\r\n        user_key: null,\r\n        user_secret: null\r\n      },\r\n      ...options\r\n    }\r\n\r\n    // Remove '/' from end of connection URLs\r\n    let api = this.options.api_url\r\n    let auth = this.options.auth_url\r\n    this.options.api_url = api[api.length - 1] === '/' ? api.slice(0, -1) : api\r\n    this.options.auth_url = auth[auth.length - 1] === '/' ? auth.slice(0, -1) : auth\r\n\r\n    // Create client\r\n    this._createClient()\r\n  }\r\n\r\n  /**\r\n   * Helper functions to wait for connection to go up\r\n   */\r\n  awaitConnection () {\r\n    return this.client.awaitConnection()\r\n  }\r\n\r\n  /**\r\n   * Helper function to see if connection is up\r\n   */\r\n  isConnected () {\r\n    return this.client.api.isConnected()\r\n  }\r\n\r\n  /**\r\n   * Subscribe to certain endpoints\r\n   */\r\n  subscribe (room, fn) {\r\n    return this.client.subscribe(room, fn)\r\n  }\r\n\r\n  /**\r\n   * Unsubscribe from endpoints again\r\n   */\r\n  unsubscribe (room) {\r\n    return this.client.unsubscribe(room)\r\n  }\r\n\r\n  /**\r\n   * RESTful methods for manual interaction\r\n   */\r\n  query (verb, query) {\r\n    return this.client.query(verb, query)\r\n  }\r\n\r\n  get (query) {\r\n    return this.query('GET', query)\r\n  }\r\n\r\n  post (url, body) {\r\n    return this.query('POST', { url, body })\r\n  }\r\n\r\n  put (url, body) {\r\n    return this.query('PUT', { url, body })\r\n  }\r\n\r\n  patch (url, body) {\r\n    return this.query('PATCH', { url, body })\r\n  }\r\n\r\n  delete (url, body) {\r\n    return this.query('DELETE', { url, body })\r\n  }\r\n\r\n  /**\r\n   * Change user at runtime. Automatically reloads connection.\r\n   */\r\n  login (user, secret) {\r\n    return this.client.login(user, secret)\r\n  }\r\n\r\n  /**\r\n   * Manually set refresh token. This way user credentials won't be exposed to this package.\r\n   */\r\n  async setRefreshToken (token) {\r\n    this.client.auth.refresh_token = token\r\n  }\r\n\r\n  /**\r\n   * Retrieve current refresh token. Will await any existing authentication\r\n   * processes. Useful if the initial login can be done through user/pass but\r\n   * the refresh token needs to be stored for subsequent logins.\r\n   */\r\n  async getRefreshToken () {\r\n    return this.client.auth.refresh_token\r\n  }\r\n\r\n  /**\r\n   * Manually set access token.\r\n   */\r\n  setAccessToken (token) {\r\n    return this.client.setAccessToken(token)\r\n  }\r\n\r\n  /**\r\n   * Retrieve current access token.\r\n   */\r\n  async getAccessToken () {\r\n    return this.client.auth.access_token\r\n  }\r\n\r\n  /**\r\n   * This function is only there so it can be overwritten by the browser build\r\n   */\r\n  _createClient () {\r\n    this.client = new Client(this.options)\r\n    this.client.connect()\r\n  }\r\n}\r\n\r\nmodule.exports = Interface\r\n","import NodeConnection from '../node/connection.js'\r\n\r\nclass Connection extends NodeConnection {\r\n  async _createConnection () {\r\n    const WS = WebSocket\r\n    const url = this.apiAccessToken ? `${this.url}?bearer=${this.apiAccessToken}` : this.url\r\n\r\n    const wss = new WS(url)\r\n    wss.onopen = () => this._resumeConnection()\r\n    wss.onerror = (error) => console.log(`WebSocket Error: ${error.message}`)\r\n    wss.onclose = (close) => { if (close.code !== 1000) this._reconnect() } // Not closed deliberately\r\n    wss.onmessage = (message) => this._onMessage(message.data)\r\n    this.connection = wss\r\n  }\r\n}\r\n\r\nexport default Connection\r\n","import BrowserConnection from './connection.js'\r\nimport NodeAuth from '../node/auth.js'\r\n\r\nclass Auth extends NodeAuth {}\r\n\r\n// Implement custom Client methods manually like this\r\n// since JS has no multi-inheritance\r\nAuth.prototype._createConnection = BrowserConnection.prototype._createConnection\r\n\r\nexport default Auth\r\n","import BrowserConnection from './connection.js'\r\nimport NodeAPI from '../node/api.js'\r\n\r\nclass API extends NodeAPI {}\r\n\r\n// Implement custom Client methods manually like this\r\n// since JS has no multi-inheritance\r\nAPI.prototype._createConnection = BrowserConnection.prototype._createConnection\r\n\r\nexport default API\r\n","import NodeClient from '../node/client.js'\r\nimport BrowserAuth from './auth.js'\r\nimport BrowserAPI from './api.js'\r\n\r\nclass Client extends NodeClient {\r\n  constructor (options) {\r\n    options.isBrowser = true // Won't init node auth and API\r\n    super(options)\r\n\r\n    this.api = new BrowserAPI(this.options.api_url, this.options)\r\n    this.auth = new BrowserAuth(this.options.auth_url, {\r\n      user_key: this.options.user_key,\r\n      user_secret: this.options.user_secret\r\n    })\r\n  }\r\n}\r\n\r\nexport default Client\r\n","import NodeIndex from '../node/index.js'\r\nimport BrowserClient from './client.js'\r\n\r\nclass Interface extends NodeIndex {\r\n  _createClient () {\r\n    this.client = new BrowserClient(this.options)\r\n    this.client.connect()\r\n  }\r\n}\r\n\r\nexport default Interface\r\n"],"names":["Object","defineProperty","exports","value","Mutex","this","_queue","_pending","prototype","isLocked","acquire","_this","ticket","Promise","resolve","push","_dispatchNext","runExclusive","callback","then","release","result","e","x","length","shift","bind","Mutex_1","default","require$$0","state","[object Object]","url","options","timeout","req","delay","requestDelay","counter","reconnect","reconnectDelay","lastHeartbeat","Date","subscriptions","requests","retryQueue","requestIds","mutex","setInterval","async","isConnected","connection","close","_processRetryQueue","_createConnection","poll","clearInterval","readyState","verb","query","retry","awaitConnection","id","payload","action","body","send","JSON","stringify","err","pop","emit","customDelay","currentReqCount","unshift","request","setTimeout","Math","pow","sub","room","apiAccessToken","headers","authorization","wss","WebSocket","onopen","_resumeConnection","onerror","error","console","log","message","onclose","code","_reconnect","onmessage","_onMessage","data","parse","startsWith","replace","_processResponse","fn","find","r","response","_errCheck","reason","parseInt","undefined","isNaN","originalRequest","filter","res","ServerError","Error","statusCode","super","Connection","token","includes","EXPIRED","toString","charAt","authMutex","refresh","refresh_token","user_key","user_secret","_refreshToken","_getTokens","user","secret","access_token","isBrowser","api","API","api_url","auth","Auth","auth_url","all","connect","authorize","setAccessToken","reloadConnection","s","login","slice","_createClient","client","subscribe","unsubscribe","Client","NodeConnection","NodeAuth","BrowserConnection","NodeAPI","NodeClient","BrowserAPI","BrowserAuth","NodeIndex","BrowserClient"],"mappings":"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"}