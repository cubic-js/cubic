{"version":3,"file":"browser.js","sources":["node_modules/ws/index.js","node_modules/async-mutex/lib/Mutex.js","node_modules/async-mutex/lib/index.js","src/node/connection.js","src/node/serverError.js","src/node/api.js","src/node/auth.js","src/node/client.js","src/node/index.js","src/browser/connection.js","src/browser/auth.js","src/browser/api.js","src/browser/client.js","src/browser/index.js"],"sourcesContent":["export default {}","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Mutex = /** @class */ (function () {\n    function Mutex() {\n        this._queue = [];\n        this._pending = false;\n    }\n    Mutex.prototype.isLocked = function () {\n        return this._pending;\n    };\n    Mutex.prototype.acquire = function () {\n        var _this = this;\n        var ticket = new Promise(function (resolve) { return _this._queue.push(resolve); });\n        if (!this._pending) {\n            this._dispatchNext();\n        }\n        return ticket;\n    };\n    Mutex.prototype.runExclusive = function (callback) {\n        return this\n            .acquire()\n            .then(function (release) {\n            var result;\n            try {\n                result = callback();\n            }\n            catch (e) {\n                release();\n                throw (e);\n            }\n            return Promise\n                .resolve(result)\n                .then(function (x) { return (release(), x); }, function (e) {\n                release();\n                throw e;\n            });\n        });\n    };\n    Mutex.prototype._dispatchNext = function () {\n        if (this._queue.length > 0) {\n            this._pending = true;\n            this._queue.shift()(this._dispatchNext.bind(this));\n        }\n        else {\n            this._pending = false;\n        }\n    };\n    return Mutex;\n}());\nexports.default = Mutex;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Mutex_1 = require(\"./Mutex\");\nexports.Mutex = Mutex_1.default;\n","const WebSocket = require('ws')\r\nconst Mutex = require('async-mutex').Mutex\r\n\r\n// Pseudo helper enum for Websocket states\r\nconst state = {\r\n  CONNECTING: 0,\r\n  OPEN: 1,\r\n  CLOSING: 2,\r\n  CLOSED: 3\r\n}\r\n\r\n/**\r\n * Connection class.\r\n * Here is where the actual WebSocket connection and logic gets handled.\r\n */\r\nclass Connection {\r\n  constructor (url, options) {\r\n    this.url = url\r\n    this.options = options\r\n    this.timeout = 1000 * 30 || options.timeout\r\n    this.req = { delay: this.options.requestDelay || 500, counter: 0 }\r\n    this.reconnect = { delay: this.options.reconnectDelay || 500, counter: 0 }\r\n\r\n    this.lastHeartbeat = new Date()\r\n    this.subscriptions = []\r\n    this.requests = []\r\n    this.retryQueue = []\r\n    this.requestIds = 1\r\n    this.mutex = new Mutex()\r\n\r\n    // Heartbeat check. If the heartbeat takes too long we can assume the connection died.\r\n    setInterval(async () => {\r\n      if (new Date() - this.lastHeartbeat > this.timeout && this.isConnected()) this.connection.close(1001, 'Heartbeat took too long.')\r\n    }, this.timeout)\r\n\r\n    // Call once to start processing retry queue\r\n    this._processRetryQueue()\r\n  }\r\n\r\n  async connect () {\r\n    const release = await this.mutex.acquire()\r\n    await this._createConnection()\r\n    release()\r\n  }\r\n\r\n  /**\r\n   * Helper function to wait for connection to go up\r\n   */\r\n  awaitConnection () {\r\n    return new Promise((resolve) => {\r\n      if (this.isConnected()) resolve()\r\n      const poll = setInterval(() => {\r\n        if (this.isConnected()) {\r\n          clearInterval(poll)\r\n          resolve()\r\n        }\r\n      }, 100)\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Helper function to see if connection is open\r\n   */\r\n  isConnected () {\r\n    return this.connection && this.connection.readyState === state.OPEN\r\n  }\r\n\r\n  /**\r\n   * Make a request\r\n   */\r\n  async request (verb, query, retry = false) {\r\n    await this.awaitConnection()\r\n    return new Promise((resolve) => {\r\n      const id = this.requestIds++\r\n      const payload = { action: verb, id }\r\n      if (typeof query === 'string') payload.url = query\r\n      else {\r\n        payload.url = query.url\r\n        payload.body = query.body\r\n      }\r\n\r\n      this.requests.push({ id, resolve, verb, query, retry })\r\n      try {\r\n        this.connection.send(JSON.stringify(payload))\r\n      } catch (err) {\r\n        this.requests.pop()\r\n        this.connection.emit('error', err)\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Reload the websocket connection\r\n   */\r\n  async reloadConnection () {\r\n    await this.awaitConnection()\r\n    await this.connection.close(1001, 'Reloading connection.')\r\n  }\r\n\r\n  /**\r\n   * Push a retry into the retry queue\r\n   */\r\n  async retry (req) {\r\n    this.retryQueue.push({\r\n      verb: req.verb,\r\n      query: req.query,\r\n      id: req.retry || req.id // Use retry id if retrying a retry, otherwise the original id\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Processes the retry queue with the correct delay.\r\n   * Needs to be called once on startup.\r\n   */\r\n  async _processRetryQueue () {\r\n    setTimeout(() => this._processRetryQueue(), this.req.delay * Math.pow(2, this.req.counter))\r\n\r\n    const retry = this.retryQueue.shift()\r\n    if (retry) {\r\n      this.request(retry.verb, retry.query, retry.id)\r\n      this.req.counter++\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reconnection logic\r\n   */\r\n  async _reconnect () {\r\n    const release = await this.mutex.acquire()\r\n\r\n    // Return if connection is connecting or already open\r\n    if (this.connection && this.connection.readyState <= state.OPEN) {\r\n      release()\r\n      return\r\n    }\r\n\r\n    // Wait reconnection delay\r\n    await new Promise((resolve) => setTimeout(() => resolve(), this.reconnect.delay * Math.pow(2, this.reconnect.counter)))\r\n    this.reconnect.counter++\r\n    await this._createConnection()\r\n\r\n    release()\r\n  }\r\n\r\n  /**\r\n   * Resume requests and rebuild subscriptions\r\n   */\r\n  async _resumeConnection () {\r\n    // Resume requests that were not completed before disconnect\r\n    for (const req of this.requests) this.retry(req)\r\n\r\n    // Re-subscribe\r\n    for (const sub of this.subscriptions) {\r\n      this.connection.send(JSON.stringify({\r\n        action: 'SUBSCRIBE',\r\n        room: sub.room\r\n      }))\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create WebSocket connection\r\n   */\r\n  async _createConnection () {\r\n    const options = this.apiAccessToken ? {\r\n      headers: {\r\n        authorization: `bearer ${this.apiAccessToken}`\r\n      }\r\n    } : {}\r\n\r\n    const wss = new WebSocket(this.url, options)\r\n    wss.onopen = () => this._resumeConnection()\r\n    wss.onerror = (error) => console.log(`WebSocket Error: ${error.message}`)\r\n    wss.onclose = (close) => { if (close.code !== 1000) this._reconnect() } // Not closed deliberately\r\n    wss.onmessage = (message) => this._onMessage(message.data)\r\n    this.connection = wss\r\n  }\r\n\r\n  /**\r\n   * WebSocket message handling\r\n   */\r\n  async _onMessage (data) {\r\n    data = JSON.parse(data)\r\n\r\n    // Heartbeat\r\n    if (typeof data === 'string' && data.startsWith('primus::ping::')) {\r\n      this.lastHeartbeat = new Date()\r\n      this.connection.send(JSON.stringify(data.replace('ping', 'pong')))\r\n      this.reconnect.counter = 0 // Assume stable connection if heartbeat is received\r\n    }\r\n\r\n    // Request\r\n    else if (data.action === 'RES' && data.id) {\r\n      this._processResponse(data)\r\n    }\r\n\r\n    // Publish to subscriptions\r\n    else if (data.action === 'PUBLISH') {\r\n      for (const sub of this.subscriptions) {\r\n        if (sub.room === data.room) sub.fn(data.data)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Processes incoming request response\r\n   */\r\n  async _processResponse (data) {\r\n    const request = this.requests.find(r => r.id === data.id)\r\n    if (!request) return\r\n\r\n    // Retry if error occurred\r\n    const response = await this._errCheck(data, request.verb, request.query)\r\n    if (!response) {\r\n      this.retry(request)\r\n      return\r\n    }\r\n\r\n    // Reset req counter and resolve\r\n    this.req.counter = 0\r\n    request.resolve(response)\r\n    const originalRequest = request.retry ? this.requests.find(r => r.id === request.retry) : null\r\n    if (originalRequest) originalRequest.resolve(response)\r\n\r\n    // If original request: Filter original request and all that have the original req as retry target\r\n    // If retry request: Filter retried request and all that have the retried req as retry target\r\n    const originalFilter = (r) => r.id !== request.id && r.retry !== request.id\r\n    const retryFilter = (r) => r.id !== request.retry && r.retry !== request.retry\r\n    this.requests = this.requests.filter(!request.retry ? originalFilter : retryFilter)\r\n  }\r\n\r\n  /**\r\n   * Handle error responses. Return false on error, otherwise some truthy value.\r\n   * It's expected that you override this in a child class for more fine-grained error control.\r\n   */\r\n  async _errCheck (res, verb, query) {\r\n    if (res.body.error) throw res\r\n    else return res.body\r\n  }\r\n}\r\n\r\nmodule.exports = Connection\r\n","class ServerError extends Error {\r\n  constructor ({ statusCode, body }, query) {\r\n    const error = body.error ? body.error + `(${body.reason})` : body\r\n    super(`Cubic-client encountered an error while requesting ${query.url || query}: ${statusCode} - ${error}`)\r\n    this.statusCode = statusCode\r\n    this.reason = body.reason\r\n    this.error = body.error\r\n  }\r\n}\r\n\r\nmodule.exports = ServerError\r\n","const Connection = require('./connection.js')\r\nconst ServerError = require('./serverError.js')\r\n\r\n/**\r\n * API class.\r\n * Handles the connection to the API server.\r\n */\r\nclass API extends Connection {\r\n  /**\r\n   * Sets access token for API\r\n   */\r\n  async setAccessToken (token) {\r\n    this.apiAccessToken = token\r\n  }\r\n\r\n  async _errCheck (res, verb, query) {\r\n    // If expired: return custom object to so parent client can refresh token\r\n    if (res.body && res.body.reason && res.body.reason.includes('jwt expired')) {\r\n      return { EXPIRED: true, verb, query }\r\n    }\r\n\r\n    // Request timed out in queue stack -> push it back to the end\r\n    else if (!res.statusCode && res.includes('timed out')) return false\r\n\r\n    // Rate Limited\r\n    else if (res.statusCode === 429) return false\r\n\r\n    // Nodes are busy -> retry\r\n    else if (res.statusCode === 503) return false\r\n\r\n    // Unhandled error\r\n    else if (parseInt(res.statusCode.toString().charAt(0)) > 3) throw new ServerError(res, query)\r\n\r\n    // No error\r\n    return res.body\r\n  }\r\n}\r\n\r\nmodule.exports = API\r\n","const Connection = require('./connection.js')\r\nconst Mutex = require('async-mutex').Mutex\r\n\r\n/**\r\n * Authentication class.\r\n * Handles the connection to the auth server.\r\n */\r\nclass Auth extends Connection {\r\n  constructor (url, options) {\r\n    super(url, options)\r\n\r\n    this.authMutex = new Mutex()\r\n  }\r\n\r\n  /**\r\n   * Get tokens for API authentication if credentials are provided\r\n   */\r\n  async authorize (refresh = this.refresh_token) {\r\n    if (refresh || (this.options.user_key && this.options.user_secret)) {\r\n      return refresh ? this._refreshToken() : this._getTokens()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Runtime login\r\n   */\r\n  login (user, secret) {\r\n    this.options.user_key = user\r\n    this.options.user_secret = secret\r\n    return this._getTokens()\r\n  }\r\n\r\n  /**\r\n   * Get tokens via /authenticate request\r\n   */\r\n  async _getTokens () {\r\n    const body = {\r\n      user_key: this.options.user_key,\r\n      user_secret: this.options.user_secret\r\n    }\r\n\r\n    const res = await this.request('POST', { url: '/authenticate', body })\r\n    this.access_token = res.access_token\r\n    this.refresh_token = res.refresh_token\r\n  }\r\n\r\n  /**\r\n   * Generate new access token\r\n   */\r\n  async _refreshToken () {\r\n    const release = await this.authMutex.acquire()\r\n\r\n    const body = { refresh_token: this.refresh_token }\r\n    const res = await this.request('POST', { url: '/refresh', body })\r\n    this.access_token = res.access_token\r\n\r\n    release()\r\n  }\r\n\r\n  async _errCheck (res, verb, query) {\r\n    // Auth error\r\n    if (res.statusCode >= 400) {\r\n      if (res.statusCode !== 503 && res.statusCode !== 404 && res.statusCode !== 429) {\r\n        console.error('Cubic-client encountered an error while authenticating:')\r\n        console.error(res.body)\r\n        console.error(`retrying... \\n`)\r\n        return false\r\n      }\r\n    }\r\n\r\n    // No error\r\n    return res.body\r\n  }\r\n}\r\n\r\nmodule.exports = Auth\r\n","const API = require('./api.js')\r\nconst Auth = require('./auth.js')\r\n\r\n/**\r\n * Client class.\r\n * This is the actual client that handles auth and api logic.\r\n */\r\nclass Client {\r\n  constructor (options) {\r\n    this.options = options\r\n\r\n    if (!this.options.isBrowser) {\r\n      this.api = new API(this.options.api_url, this.options)\r\n      this.auth = new Auth(this.options.auth_url, {\r\n        user_key: this.options.user_key,\r\n        user_secret: this.options.user_secret\r\n      })\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Helper functions to wait for connection to go up\r\n   */\r\n  awaitConnection () {\r\n    return Promise.all([this.api.awaitConnection(), this.auth.awaitConnection()])\r\n  }\r\n\r\n  async connect () {\r\n    await this.auth.connect()\r\n    await this.auth.authorize()\r\n    await this.api.setAccessToken(this.auth.access_token)\r\n    await this.api.connect()\r\n  }\r\n\r\n  async query (verb, query) {\r\n    const res = await this.api.request(verb, query)\r\n\r\n    // Refresh token if expired\r\n    if (res.EXPIRED) {\r\n      await this.auth.authorize()\r\n      await this.api.setAccessToken(this.auth.access_token)\r\n      return this.query(res.verb, res.query)\r\n    }\r\n\r\n    return res\r\n  }\r\n\r\n  /**\r\n   * Subscribe to certain endpoints\r\n   */\r\n  async subscribe (room, fn) {\r\n    await this.api.awaitConnection()\r\n    this.api.connection.send(JSON.stringify({\r\n      action: 'SUBSCRIBE',\r\n      room\r\n    }))\r\n    this.api.subscriptions.push({ room, fn })\r\n  }\r\n\r\n  /**\r\n   * Unsubscribe from endpoints again\r\n   */\r\n  async unsubscribe (room) {\r\n    await this.api.awaitConnection()\r\n    this.api.connection.send(JSON.stringify({\r\n      action: 'UNSUBSCRIBE',\r\n      room\r\n    }))\r\n    this.api.subscriptions = this.api.subscriptions.filter(s => s.room !== room)\r\n  }\r\n\r\n  /**\r\n   * Change auth user and reload api\r\n   */\r\n  async login (user, secret) {\r\n    await this.awaitConnection()\r\n    await this.auth.login(user, secret)\r\n    await this.api.setAccessToken(this.auth.access_token)\r\n    await this.api.reloadConnection()\r\n  }\r\n\r\n  /**\r\n   * Set access token and reload api\r\n   */\r\n  async setAccessToken (token) {\r\n    this.auth.access_token = token\r\n    await this.api.setAccessToken(this.auth.access_token)\r\n    await this.api.reloadConnection()\r\n  }\r\n}\r\n\r\nmodule.exports = Client\r\n","const Client = require('./client.js')\r\n\r\n/**\r\n * Client API. Provides a public interface for the actual client.\r\n */\r\nclass Interface {\r\n  constructor (options) {\r\n    this.options = {\r\n      ...{\r\n        api_url: 'ws://localhost:3003/ws',\r\n        auth_url: 'ws://localhost:3030/ws',\r\n        user_key: null,\r\n        user_secret: null\r\n      },\r\n      ...options\r\n    }\r\n\r\n    // Remove '/' from end of connection URLs\r\n    let api = this.options.api_url\r\n    let auth = this.options.auth_url\r\n    this.options.api_url = api[api.length - 1] === '/' ? api.slice(0, -1) : api\r\n    this.options.auth_url = auth[auth.length - 1] === '/' ? auth.slice(0, -1) : auth\r\n\r\n    // Create client\r\n    this._createClient()\r\n  }\r\n\r\n  /**\r\n   * Helper functions to wait for connection to go up\r\n   */\r\n  awaitConnection () {\r\n    return this.client.awaitConnection()\r\n  }\r\n\r\n  /**\r\n   * Helper function to see if connection is up\r\n   */\r\n  isConnected () {\r\n    return this.client.api.isConnected()\r\n  }\r\n\r\n  /**\r\n   * Subscribe to certain endpoints\r\n   */\r\n  subscribe (room, fn) {\r\n    return this.client.subscribe(room, fn)\r\n  }\r\n\r\n  /**\r\n   * Unsubscribe from endpoints again\r\n   */\r\n  unsubscribe (room) {\r\n    return this.client.unsubscribe(room)\r\n  }\r\n\r\n  /**\r\n   * RESTful methods for manual interaction\r\n   */\r\n  query (verb, query) {\r\n    return this.client.query(verb, query)\r\n  }\r\n\r\n  get (query) {\r\n    return this.query('GET', query)\r\n  }\r\n\r\n  post (url, body) {\r\n    return this.query('POST', { url, body })\r\n  }\r\n\r\n  put (url, body) {\r\n    return this.query('PUT', { url, body })\r\n  }\r\n\r\n  patch (url, body) {\r\n    return this.query('PATCH', { url, body })\r\n  }\r\n\r\n  delete (url, body) {\r\n    return this.query('DELETE', { url, body })\r\n  }\r\n\r\n  /**\r\n   * Change user at runtime. Automatically reloads connection.\r\n   */\r\n  login (user, secret) {\r\n    return this.client.login(user, secret)\r\n  }\r\n\r\n  /**\r\n   * Manually set refresh token. This way user credentials won't be exposed to this package.\r\n   */\r\n  async setRefreshToken (token) {\r\n    this.client.auth.refresh_token = token\r\n  }\r\n\r\n  /**\r\n   * Retrieve current refresh token. Will await any existing authentication\r\n   * processes. Useful if the initial login can be done through user/pass but\r\n   * the refresh token needs to be stored for subsequent logins.\r\n   */\r\n  async getRefreshToken () {\r\n    return this.client.auth.refresh_token\r\n  }\r\n\r\n  /**\r\n   * Manually set access token.\r\n   */\r\n  setAccessToken (token) {\r\n    return this.client.setAccessToken(token)\r\n  }\r\n\r\n  /**\r\n   * Retrieve current access token.\r\n   */\r\n  async getAccessToken () {\r\n    return this.client.auth.access_token\r\n  }\r\n\r\n  /**\r\n   * This function is only there so it can be overwritten by the browser build\r\n   */\r\n  _createClient () {\r\n    this.client = new Client(this.options)\r\n    this.client.connect()\r\n  }\r\n}\r\n\r\nmodule.exports = Interface\r\n","import NodeConnection from '../node/connection.js'\r\n\r\nclass Connection extends NodeConnection {\r\n  async _createConnection () {\r\n    const WS = WebSocket\r\n    const url = this.apiAccessToken ? `${this.url}?bearer=${this.apiAccessToken}` : this.url\r\n\r\n    const wss = new WS(url)\r\n    wss.onopen = () => this._resumeConnection()\r\n    wss.onerror = (error) => console.log(`WebSocket Error: ${error.message}`)\r\n    wss.onclose = (close) => { if (close.code !== 1000) this._reconnect() } // Not closed deliberately\r\n    wss.onmessage = (message) => this._onMessage(message.data)\r\n    this.connection = wss\r\n  }\r\n}\r\n\r\nexport default Connection\r\n","import BrowserConnection from './connection.js'\r\nimport NodeAuth from '../node/auth.js'\r\n\r\nclass Auth extends NodeAuth {}\r\n\r\n// Implement custom Client methods manually like this\r\n// since JS has no multi-inheritance\r\nAuth.prototype._createConnection = BrowserConnection.prototype._createConnection\r\n\r\nexport default Auth\r\n","import BrowserConnection from './connection.js'\r\nimport NodeAPI from '../node/api.js'\r\n\r\nclass API extends NodeAPI {}\r\n\r\n// Implement custom Client methods manually like this\r\n// since JS has no multi-inheritance\r\nAPI.prototype._createConnection = BrowserConnection.prototype._createConnection\r\n\r\nexport default API\r\n","import NodeClient from '../node/client.js'\r\nimport BrowserAuth from './auth.js'\r\nimport BrowserAPI from './api.js'\r\n\r\nclass Client extends NodeClient {\r\n  constructor (options) {\r\n    options.isBrowser = true // Won't init node auth and API\r\n    super(options)\r\n\r\n    this.api = new BrowserAPI(this.options.api_url, this.options)\r\n    this.auth = new BrowserAuth(this.options.auth_url, {\r\n      user_key: this.options.user_key,\r\n      user_secret: this.options.user_secret\r\n    })\r\n  }\r\n}\r\n\r\nexport default Client\r\n","import NodeIndex from '../node/index.js'\r\nimport BrowserClient from './client.js'\r\n\r\nclass Interface extends NodeIndex {\r\n  _createClient () {\r\n    this.client = new BrowserClient(this.options)\r\n    this.client.connect()\r\n  }\r\n}\r\n\r\nexport default Interface\r\n"],"names":["Object","defineProperty","exports","value","Mutex","this","_queue","_pending","prototype","isLocked","acquire","_this","ticket","Promise","resolve","push","_dispatchNext","runExclusive","callback","then","release","result","e","x","length","shift","bind","Mutex_1","default","require$$0","state","[object Object]","url","options","timeout","req","delay","requestDelay","counter","reconnect","reconnectDelay","lastHeartbeat","Date","subscriptions","requests","retryQueue","requestIds","mutex","setInterval","async","isConnected","connection","close","_processRetryQueue","_createConnection","poll","clearInterval","readyState","verb","query","retry","awaitConnection","id","payload","action","body","send","JSON","stringify","err","pop","emit","setTimeout","Math","pow","request","sub","room","apiAccessToken","headers","authorization","wss","WebSocket","onopen","_resumeConnection","onerror","error","console","log","message","onclose","code","_reconnect","onmessage","_onMessage","data","parse","startsWith","replace","_processResponse","fn","find","r","response","_errCheck","originalRequest","filter","res","ServerError","Error","statusCode","reason","super","Connection","token","includes","EXPIRED","parseInt","toString","charAt","authMutex","refresh","refresh_token","user_key","user_secret","_refreshToken","_getTokens","user","secret","access_token","isBrowser","api","API","api_url","auth","Auth","auth_url","all","connect","authorize","setAccessToken","s","login","reloadConnection","slice","_createClient","client","subscribe","unsubscribe","Client","NodeConnection","NodeAuth","BrowserConnection","NodeAPI","NodeClient","BrowserAPI","BrowserAuth","NodeIndex","BrowserClient"],"mappings":"aAAA,MAAe,2LCCfA,OAAOC,eAAeC,EAAS,aAAc,CAAEC,OAAO,IACtD,IAAIC,EAAuB,WACvB,SAASA,IACLC,KAAKC,OAAS,GACdD,KAAKE,UAAW,EA0CpB,OAxCAH,EAAMI,UAAUC,SAAW,WACvB,OAAOJ,KAAKE,UAEhBH,EAAMI,UAAUE,QAAU,WACtB,IAAIC,EAAQN,KACRO,EAAS,IAAIC,SAAQ,SAAUC,GAAW,OAAOH,EAAML,OAAOS,KAAKD,MAIvE,OAHKT,KAAKE,UACNF,KAAKW,gBAEFJ,GAEXR,EAAMI,UAAUS,aAAe,SAAUC,GACrC,OAAOb,KACFK,UACAS,MAAK,SAAUC,GAChB,IAAIC,EACJ,IACIA,EAASH,IAEb,MAAOI,GAEH,MADAF,MAGJ,OAAOP,QACFC,QAAQO,GACRF,MAAK,SAAUI,GAAK,OAAQH,IAAWG,KAAO,SAAUD,GAEzD,MADAF,IACME,SAIlBlB,EAAMI,UAAUQ,cAAgB,WACxBX,KAAKC,OAAOkB,OAAS,GACrBnB,KAAKE,UAAW,EAChBF,KAAKC,OAAOmB,OAAZpB,CAAoBA,KAAKW,cAAcU,KAAKrB,QAG5CA,KAAKE,UAAW,GAGjBH,KAEXF,UAAkBE,iCChDlBJ,OAAOC,eAAeC,EAAS,aAAc,CAAEC,OAAO,IAEtDD,QAAgByB,EAAQC,wBCFxB,MAAMxB,EAAQyB,EAAuBzB,MAG/B0B,EAEE,EA2OR,MAlOA,MACEC,YAAaC,EAAKC,GAChB5B,KAAK2B,IAAMA,EACX3B,KAAK4B,QAAUA,EACf5B,KAAK6B,QAAU,IACf7B,KAAK8B,IAAM,CAAEC,MAAO/B,KAAK4B,QAAQI,cAAgB,IAAKC,QAAS,GAC/DjC,KAAKkC,UAAY,CAAEH,MAAO/B,KAAK4B,QAAQO,gBAAkB,IAAKF,QAAS,GAEvEjC,KAAKoC,cAAgB,IAAIC,KACzBrC,KAAKsC,cAAgB,GACrBtC,KAAKuC,SAAW,GAChBvC,KAAKwC,WAAa,GAClBxC,KAAKyC,WAAa,EAClBzC,KAAK0C,MAAQ,IAAI3C,EAGjB4C,YAAYC,UACN,IAAIP,KAASrC,KAAKoC,cAAgBpC,KAAK6B,SAAW7B,KAAK6C,eAAe7C,KAAK8C,WAAWC,MAAM,KAAM,6BACrG/C,KAAK6B,SAGR7B,KAAKgD,qBAGPtB,gBACE,MAAMX,QAAgBf,KAAK0C,MAAMrC,gBAC3BL,KAAKiD,oBACXlC,IAMFW,kBACE,OAAO,IAAIlB,QAASC,IACdT,KAAK6C,eAAepC,IACxB,MAAMyC,EAAOP,YAAY,KACnB3C,KAAK6C,gBACPM,cAAcD,GACdzC,MAED,OAOPiB,cACE,OAAO1B,KAAK8C,YAAc9C,KAAK8C,WAAWM,aAAe3B,EAM3DC,cAAe2B,EAAMC,EAAOC,GAAQ,GAElC,aADMvD,KAAKwD,kBACJ,IAAIhD,QAASC,IAClB,MAAMgD,EAAKzD,KAAKyC,aACViB,EAAU,CAAEC,OAAQN,EAAMI,GAAAA,GACX,iBAAVH,EAAoBI,EAAQ/B,IAAM2B,GAE3CI,EAAQ/B,IAAM2B,EAAM3B,IACpB+B,EAAQE,KAAON,EAAMM,MAGvB5D,KAAKuC,SAAS7B,KAAK,CAAE+C,GAAAA,EAAIhD,QAAAA,EAAS4C,KAAAA,EAAMC,MAAAA,EAAOC,MAAAA,IAC/C,IACEvD,KAAK8C,WAAWe,KAAKC,KAAKC,UAAUL,IACpC,MAAOM,GACPhE,KAAKuC,SAAS0B,MACdjE,KAAK8C,WAAWoB,KAAK,QAASF,MAQpCtC,+BACQ1B,KAAKwD,wBACLxD,KAAK8C,WAAWC,MAAM,KAAM,yBAMpCrB,YAAaI,GACX9B,KAAKwC,WAAW9B,KAAK,CACnB2C,KAAMvB,EAAIuB,KACVC,MAAOxB,EAAIwB,MACXG,GAAI3B,EAAIyB,OAASzB,EAAI2B,KAQzB/B,2BACEyC,WAAW,IAAMnE,KAAKgD,qBAAsBhD,KAAK8B,IAAIC,MAAQqC,KAAKC,IAAI,EAAGrE,KAAK8B,IAAIG,UAElF,MAAMsB,EAAQvD,KAAKwC,WAAWpB,QAC1BmC,IACFvD,KAAKsE,QAAQf,EAAMF,KAAME,EAAMD,MAAOC,EAAME,IAC5CzD,KAAK8B,IAAIG,WAObP,mBACE,MAAMX,QAAgBf,KAAK0C,MAAMrC,UAG7BL,KAAK8C,YAAc9C,KAAK8C,WAAWM,YAAc3B,UAM/C,IAAIjB,QAASC,GAAY0D,WAAW,IAAM1D,IAAWT,KAAKkC,UAAUH,MAAQqC,KAAKC,IAAI,EAAGrE,KAAKkC,UAAUD,WAC7GjC,KAAKkC,UAAUD,gBACTjC,KAAKiD,qBAPTlC,IAeJW,0BAEE,IAAK,MAAMI,KAAO9B,KAAKuC,SAAUvC,KAAKuD,MAAMzB,GAG5C,IAAK,MAAMyC,KAAOvE,KAAKsC,cACrBtC,KAAK8C,WAAWe,KAAKC,KAAKC,UAAU,CAClCJ,OAAQ,YACRa,KAAMD,EAAIC,QAQhB9C,0BACE,MAAME,EAAU5B,KAAKyE,eAAiB,CACpCC,QAAS,CACPC,cAAe,UAAU3E,KAAKyE,mBAE9B,GAEEG,EAAM,IAAIC,EAAU7E,KAAK2B,IAAKC,GACpCgD,EAAIE,OAAS,IAAM9E,KAAK+E,oBACxBH,EAAII,QAAWC,GAAUC,QAAQC,IAAI,oBAAoBF,EAAMG,WAC/DR,EAAIS,QAAWtC,IAA+B,MAAfA,EAAMuC,MAAetF,KAAKuF,cACzDX,EAAIY,UAAaJ,GAAYpF,KAAKyF,WAAWL,EAAQM,MACrD1F,KAAK8C,WAAa8B,EAMpBlD,iBAAkBgE,GAIhB,GAAoB,iBAHpBA,EAAO5B,KAAK6B,MAAMD,KAGcA,EAAKE,WAAW,kBAC9C5F,KAAKoC,cAAgB,IAAIC,KACzBrC,KAAK8C,WAAWe,KAAKC,KAAKC,UAAU2B,EAAKG,QAAQ,OAAQ,UACzD7F,KAAKkC,UAAUD,QAAU,OAItB,GAAoB,QAAhByD,EAAK/B,QAAoB+B,EAAKjC,GACrCzD,KAAK8F,iBAAiBJ,QAInB,GAAoB,YAAhBA,EAAK/B,OACZ,IAAK,MAAMY,KAAOvE,KAAKsC,cACjBiC,EAAIC,OAASkB,EAAKlB,MAAMD,EAAIwB,GAAGL,EAAKA,MAQ9ChE,uBAAwBgE,GACtB,MAAMpB,EAAUtE,KAAKuC,SAASyD,KAAKC,GAAKA,EAAExC,KAAOiC,EAAKjC,IACtD,IAAKa,EAAS,OAGd,MAAM4B,QAAiBlG,KAAKmG,UAAUT,EAAMpB,EAAQjB,KAAMiB,EAAQhB,OAClE,IAAK4C,EAEH,YADAlG,KAAKuD,MAAMe,GAKbtE,KAAK8B,IAAIG,QAAU,EACnBqC,EAAQ7D,QAAQyF,GAChB,MAAME,EAAkB9B,EAAQf,MAAQvD,KAAKuC,SAASyD,KAAKC,GAAKA,EAAExC,KAAOa,EAAQf,OAAS,KACtF6C,GAAiBA,EAAgB3F,QAAQyF,GAM7ClG,KAAKuC,SAAWvC,KAAKuC,SAAS8D,OAAQ/B,EAAQf,MADzB0C,GAAMA,EAAExC,KAAOa,EAAQf,OAAS0C,EAAE1C,QAAUe,EAAQf,MADjD0C,GAAMA,EAAExC,KAAOa,EAAQb,IAAMwC,EAAE1C,QAAUe,EAAQb,IAS3E/B,gBAAiB4E,EAAKjD,EAAMC,GAC1B,GAAIgD,EAAI1C,KAAKqB,MAAO,MAAMqB,EACrB,OAAOA,EAAI1C,OC7OpB,MAAM2C,UAAoBC,MACxB9E,aAAa+E,WAAEA,EAAU7C,KAAEA,GAAQN,GACjC,MAAM2B,EAAQrB,EAAKqB,MAAQrB,EAAKqB,MAAQ,IAAIrB,EAAK8C,UAAY9C,EAC7D+C,MAAM,sDAAsDrD,EAAM3B,KAAO2B,MAAUmD,OAAgBxB,KACnGjF,KAAKyG,WAAaA,EAClBzG,KAAK0G,OAAS9C,EAAK8C,OACnB1G,KAAKiF,MAAQrB,EAAKqB,OAItB,MAAiBsB,EC4BjB,MA/BA,cAAkBK,EAIhBlF,qBAAsBmF,GACpB7G,KAAKyE,eAAiBoC,EAGxBnF,gBAAiB4E,EAAKjD,EAAMC,GAE1B,GAAIgD,EAAI1C,MAAQ0C,EAAI1C,KAAK8C,QAAUJ,EAAI1C,KAAK8C,OAAOI,SAAS,eAC1D,MAAO,CAAEC,SAAS,EAAM1D,KAAAA,EAAMC,MAAAA,GAI3B,IAAKgD,EAAIG,YAAcH,EAAIQ,SAAS,aAAc,OAAO,EAGzD,GAAuB,MAAnBR,EAAIG,WAAoB,OAAO,EAGnC,GAAuB,MAAnBH,EAAIG,WAAoB,OAAO,EAGnC,GAAIO,SAASV,EAAIG,WAAWQ,WAAWC,OAAO,IAAM,EAAG,MAAM,IAAIX,EAAYD,EAAKhD,GAGvF,OAAOgD,EAAI1C,OCjCf,MAAM7D,EAAQyB,EAAuBzB,MA0ErC,MApEA,cAAmB6G,EACjBlF,YAAaC,EAAKC,GAChB+E,MAAMhF,EAAKC,GAEX5B,KAAKmH,UAAY,IAAIpH,EAMvB2B,gBAAiB0F,EAAUpH,KAAKqH,eAC9B,GAAID,GAAYpH,KAAK4B,QAAQ0F,UAAYtH,KAAK4B,QAAQ2F,YACpD,OAAOH,EAAUpH,KAAKwH,gBAAkBxH,KAAKyH,aAOjD/F,MAAOgG,EAAMC,GAGX,OAFA3H,KAAK4B,QAAQ0F,SAAWI,EACxB1H,KAAK4B,QAAQ2F,YAAcI,EACpB3H,KAAKyH,aAMd/F,mBACE,MAAMkC,EAAO,CACX0D,SAAUtH,KAAK4B,QAAQ0F,SACvBC,YAAavH,KAAK4B,QAAQ2F,aAGtBjB,QAAYtG,KAAKsE,QAAQ,OAAQ,CAAE3C,IAAK,gBAAiBiC,KAAAA,IAC/D5D,KAAK4H,aAAetB,EAAIsB,aACxB5H,KAAKqH,cAAgBf,EAAIe,cAM3B3F,sBACE,MAAMX,QAAgBf,KAAKmH,UAAU9G,UAE/BuD,EAAO,CAAEyD,cAAerH,KAAKqH,eAC7Bf,QAAYtG,KAAKsE,QAAQ,OAAQ,CAAE3C,IAAK,WAAYiC,KAAAA,IAC1D5D,KAAK4H,aAAetB,EAAIsB,aAExB7G,IAGFW,gBAAiB4E,EAAKjD,EAAMC,GAE1B,OAAIgD,EAAIG,YAAc,KACG,MAAnBH,EAAIG,YAAyC,MAAnBH,EAAIG,YAAyC,MAAnBH,EAAIG,YAC1DvB,QAAQD,MAAM,2DACdC,QAAQD,MAAMqB,EAAI1C,MAClBsB,QAAQD,MAAM,mBACP,GAKJqB,EAAI1C,OCoBf,MApFA,MACElC,YAAaE,GACX5B,KAAK4B,QAAUA,EAEV5B,KAAK4B,QAAQiG,YAChB7H,KAAK8H,IAAM,IAAIC,EAAI/H,KAAK4B,QAAQoG,QAAShI,KAAK4B,SAC9C5B,KAAKiI,KAAO,IAAIC,EAAKlI,KAAK4B,QAAQuG,SAAU,CAC1Cb,SAAUtH,KAAK4B,QAAQ0F,SACvBC,YAAavH,KAAK4B,QAAQ2F,eAQhC7F,kBACE,OAAOlB,QAAQ4H,IAAI,CAACpI,KAAK8H,IAAItE,kBAAmBxD,KAAKiI,KAAKzE,oBAG5D9B,sBACQ1B,KAAKiI,KAAKI,gBACVrI,KAAKiI,KAAKK,kBACVtI,KAAK8H,IAAIS,eAAevI,KAAKiI,KAAKL,oBAClC5H,KAAK8H,IAAIO,UAGjB3G,YAAa2B,EAAMC,GACjB,MAAMgD,QAAYtG,KAAK8H,IAAIxD,QAAQjB,EAAMC,GAGzC,OAAIgD,EAAIS,eACA/G,KAAKiI,KAAKK,kBACVtI,KAAK8H,IAAIS,eAAevI,KAAKiI,KAAKL,cACjC5H,KAAKsD,MAAMgD,EAAIjD,KAAMiD,EAAIhD,QAG3BgD,EAMT5E,gBAAiB8C,EAAMuB,SACf/F,KAAK8H,IAAItE,kBACfxD,KAAK8H,IAAIhF,WAAWe,KAAKC,KAAKC,UAAU,CACtCJ,OAAQ,YACRa,KAAAA,KAEFxE,KAAK8H,IAAIxF,cAAc5B,KAAK,CAAE8D,KAAAA,EAAMuB,GAAAA,IAMtCrE,kBAAmB8C,SACXxE,KAAK8H,IAAItE,kBACfxD,KAAK8H,IAAIhF,WAAWe,KAAKC,KAAKC,UAAU,CACtCJ,OAAQ,cACRa,KAAAA,KAEFxE,KAAK8H,IAAIxF,cAAgBtC,KAAK8H,IAAIxF,cAAc+D,OAAOmC,GAAKA,EAAEhE,OAASA,GAMzE9C,YAAagG,EAAMC,SACX3H,KAAKwD,wBACLxD,KAAKiI,KAAKQ,MAAMf,EAAMC,SACtB3H,KAAK8H,IAAIS,eAAevI,KAAKiI,KAAKL,oBAClC5H,KAAK8H,IAAIY,mBAMjBhH,qBAAsBmF,GACpB7G,KAAKiI,KAAKL,aAAef,QACnB7G,KAAK8H,IAAIS,eAAevI,KAAKiI,KAAKL,oBAClC5H,KAAK8H,IAAIY,qBCyCnB,MA3HA,MACEhH,YAAaE,GACX5B,KAAK4B,QAAU,CAEXoG,QAAS,yBACTG,SAAU,yBACVb,SAAU,KACVC,YAAa,QAEZ3F,GAIL,IAAIkG,EAAM9H,KAAK4B,QAAQoG,QACnBC,EAAOjI,KAAK4B,QAAQuG,SACxBnI,KAAK4B,QAAQoG,QAAkC,MAAxBF,EAAIA,EAAI3G,OAAS,GAAa2G,EAAIa,MAAM,GAAI,GAAKb,EACxE9H,KAAK4B,QAAQuG,SAAqC,MAA1BF,EAAKA,EAAK9G,OAAS,GAAa8G,EAAKU,MAAM,GAAI,GAAKV,EAG5EjI,KAAK4I,gBAMPlH,kBACE,OAAO1B,KAAK6I,OAAOrF,kBAMrB9B,cACE,OAAO1B,KAAK6I,OAAOf,IAAIjF,cAMzBnB,UAAW8C,EAAMuB,GACf,OAAO/F,KAAK6I,OAAOC,UAAUtE,EAAMuB,GAMrCrE,YAAa8C,GACX,OAAOxE,KAAK6I,OAAOE,YAAYvE,GAMjC9C,MAAO2B,EAAMC,GACX,OAAOtD,KAAK6I,OAAOvF,MAAMD,EAAMC,GAGjC5B,IAAK4B,GACH,OAAOtD,KAAKsD,MAAM,MAAOA,GAG3B5B,KAAMC,EAAKiC,GACT,OAAO5D,KAAKsD,MAAM,OAAQ,CAAE3B,IAAAA,EAAKiC,KAAAA,IAGnClC,IAAKC,EAAKiC,GACR,OAAO5D,KAAKsD,MAAM,MAAO,CAAE3B,IAAAA,EAAKiC,KAAAA,IAGlClC,MAAOC,EAAKiC,GACV,OAAO5D,KAAKsD,MAAM,QAAS,CAAE3B,IAAAA,EAAKiC,KAAAA,IAGpClC,OAAQC,EAAKiC,GACX,OAAO5D,KAAKsD,MAAM,SAAU,CAAE3B,IAAAA,EAAKiC,KAAAA,IAMrClC,MAAOgG,EAAMC,GACX,OAAO3H,KAAK6I,OAAOJ,MAAMf,EAAMC,GAMjCjG,sBAAuBmF,GACrB7G,KAAK6I,OAAOZ,KAAKZ,cAAgBR,EAQnCnF,wBACE,OAAO1B,KAAK6I,OAAOZ,KAAKZ,cAM1B3F,eAAgBmF,GACd,OAAO7G,KAAK6I,OAAON,eAAe1B,GAMpCnF,uBACE,OAAO1B,KAAK6I,OAAOZ,KAAKL,aAM1BlG,gBACE1B,KAAK6I,OAAS,IAAIG,EAAOhJ,KAAK4B,SAC9B5B,KAAK6I,OAAOR,YC1HhB,MAAMzB,UAAmBqC,EACvBvH,0BACE,MAGMkD,EAAM,IAHDC,UACC7E,KAAKyE,eAAiB,GAAGzE,KAAK2B,cAAc3B,KAAKyE,iBAAmBzE,KAAK2B,KAGrFiD,EAAIE,OAAS,IAAM9E,KAAK+E,oBACxBH,EAAII,QAAWC,GAAUC,QAAQC,IAAI,oBAAoBF,EAAMG,WAC/DR,EAAIS,QAAWtC,IAA+B,MAAfA,EAAMuC,MAAetF,KAAKuF,cACzDX,EAAIY,UAAaJ,GAAYpF,KAAKyF,WAAWL,EAAQM,MACrD1F,KAAK8C,WAAa8B,GCTtB,MAAMsD,UAAagB,GAInBhB,EAAK/H,UAAU8C,kBAAoBkG,EAAkBhJ,UAAU8C,kBCJ/D,MAAM8E,UAAYqB,GAIlBrB,EAAI5H,UAAU8C,kBAAoBkG,EAAkBhJ,UAAU8C,kBCH9D,MAAM+F,UAAeK,EACnB3H,YAAaE,GACXA,EAAQiG,WAAY,EACpBlB,MAAM/E,GAEN5B,KAAK8H,IAAM,IAAIwB,EAAWtJ,KAAK4B,QAAQoG,QAAShI,KAAK4B,SACrD5B,KAAKiI,KAAO,IAAIsB,EAAYvJ,KAAK4B,QAAQuG,SAAU,CACjDb,SAAUtH,KAAK4B,QAAQ0F,SACvBC,YAAavH,KAAK4B,QAAQ2F,8BCThC,cAAwBiC,EACtB9H,gBACE1B,KAAK6I,OAAS,IAAIY,EAAczJ,KAAK4B,SACrC5B,KAAK6I,OAAOR"}